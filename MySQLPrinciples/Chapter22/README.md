Chapter22 工作面試老大難 -- 鎖
=====
* ### 當一個交易想對這筆紀錄進行改動時，首先會看看記憶體中有沒有與這筆紀錄連結的鎖結構，如果沒有就會在記憶體中生成一個鎖結構與之連結。
* ### 鎖結構重要資訊
    * ### trx: 表示這個鎖結構是與哪個交易連結的。
    * ### is_waiting: 表示當前交易是否在等待。
    * ### trx = T1，is_waiting = false 表示獲取鎖成功，事務繼續運行。
    * ### trx = T1，is_waiting = true 表示獲取鎖失敗，事務開始等待。
    * ### 交易 T1 提交後，就會把它生成的鎖結構釋放掉，然後檢測一下還有沒有與該記錄連結的鎖結構，假設發現 T2 在等待獲取鎖，就會把交易 T2 對應的鎖結構 is_waiting 設定為 false，然後把該交易對應的執行緒喚醒，讓 T2 繼續執行。
* ### 小結
    * ### 獲取鎖成功，或加鎖成功，在記憶體中生成了對應的鎖結構，且 is_waiting 為 false，也就是交易可以繼續執行操作，當然並不是所有的家鎖操作都需要生成對應的鎖結構，有時候會有一種 "加隱式鎖" 的說法，隱式鎖並不會生成實際的鎖結構，但是仍然可以造成保護紀錄的作用，我們把為記錄增加隱式鎖的情況，也認為是獲取鎖成功。
    * ### 獲取鎖失敗，或加鎖失敗，或沒有獲取到鎖，在記憶體中生成了對應的鎖結構，且 is_waiting 為 true，也就是交易需要等待，不可以繼續執行操作。
    * ### 不加鎖，不需要在記憶體中生成對應的鎖結構 可以直接執行操作，不包括為記錄加隱式鎖的情況。
* ### 如何避免中途讀取、不可重複讀取、虛設項目讀取這些現象？
    * ### 讀取操作使用多版本併發控制 (MVCC)，寫入操作進行加鎖。
    * ### 讀取寫入操作都採用加鎖的方式。
    * ### 如果採用 MVCC 方式，讀取寫入操作彼此並不衝突，性能更高，如果採用加鎖方式， 讀取寫入操作，彼此需要排隊執行，從而影響效能。
    * ### 一般情況下我們當然願意採用 MVCC 來解決讀取寫入操作併發執行的問題，但在某些特殊的業務場景，要求必須採用加鎖的方式執行，就沒辦法了。
* ### 由於要允許 "讀讀" 情況不受影響，又要使 "寫寫"、"讀寫" 或 "寫讀" 情況中的操作相互阻塞:
    * ### 共用鎖 (Shared Lock): S 鎖，交易要讀取一筆紀錄時需要先獲取該記錄的 S 鎖。
    * ### 獨佔鎖 (Exclusive Lock): Ｘ 鎖，又稱排它鎖，在交易要改動一筆紀錄時需要先獲取該記錄的 Ｘ 鎖。
* ### 假設交易 T1 首先獲取了一筆記錄的 S 鎖，之後交易 T2 接著也要存取這筆記錄:
    * ### 如果交易 T2 想要再獲取一個紀錄的 S 鎖，那麼交易 T2 也會獲得該鎖，這也表示交易 T1 和 T2 在該記錄上同時持有 S 鎖。
    * ### 如果交易 T2 想要再獲取一個記錄的 X 鎖，那麼此操作會被阻塞，值到交易 T1 提交之後將 S 鎖釋放掉為止。
* ### 如果交易 T1 首先獲取了 X 鎖，那麼之後無論 T2 想獲取該記錄的 X 或 S 鎖，都會被阻塞，值到交易 T1 釋放 X 鎖為止。
* ### 所以 S 鎖互相相容，S 與 X 或 X 與 X 互不相容。
    | 相容性 | X 鎖 | S 鎖 |
    | -- | -- | -- |
    | X | 不相容 | 不相容 |
    | S | 不相容 | 相容 |
* ### 在讀取一筆紀錄時需要獲取該記錄的 S 鎖，其實這是不嚴謹的，有時候我們想在讀取紀錄時就獲取紀錄的 X 鎖，我們把這種在讀取紀錄前就為該記錄加鎖的讀取方式稱為 "鎖定讀取 (Locking Read)"。
    ```
    # 對讀取的記錄加 S 鎖
    SELECT ... LOCK IN SHARE MODE;

    # 對讀取的記錄加 X 鎖。
    SELECT ... FOR UPDATE;
    ```
* ### 寫入操作
    * ### DELETE: 先定位待刪除記錄在 B+ 樹的位置，然後獲取這筆記錄的 X 鎖。
    * ### UPDATE: 先定位待修改記錄在 B+ 樹的位置，然後獲取這筆記錄的 X 鎖。
        * ### 如果未修改鍵值，且儲存空間無變化，就更新值。
        * ### 如果未修改鍵值，但儲存空間有變化，會在獲取該記錄 X 鎖後將記錄刪除，再插入新記錄。
        * ### 如果修改鍵值，就是執行 DELETE 再執行 INSERT。
    * ### INSERT: 一般情況下新插入的一筆紀錄，受隱式鎖保護。
* ### 多粒度鎖: 一個交易也可以在表等級進行加鎖，自然就將其稱為表級鎖或表鎖，對一個表加鎖會影響表中的所有紀錄，我們就說這個鎖的粒度比較粗。
    * ### 給表加 S 鎖
        * ### 別的交易 "可以" 繼續獲得該 "表" 與 "表中記錄" 的 S 鎖。
        * ### 別的交易 "不可以" 繼續獲得該 "表" 與 "表中記錄" 的 X 鎖。
    * ### 給表加 X 鎖
        * ### 別的交易什麼都拿不到。
    * ### 如何判別表中記錄是否上鎖
        * ### 意象共用鎖 (Intention Shared Lock, IS): 上記錄 S 鎖前要先上 IS 鎖。
        * ### 意象獨佔鎖 (Intention Exclusive Lock, IX): 上記錄 X 鎖前要先上 IX 鎖。
    | 相容性 (表級鎖) | X | IX | S | IS |
    | -- | -- | -- | -- | -- |
    | X | 不相容 | 不相容 | 不相容 | 不相容 |
    | IX | 不相容 | 相容 | 不相容 | 相容 |
    | S | 不相容 | 不相容 | 相容 | 相容 |
    | IS | 不相容 | 相容 | 相容 | 相容 |
* ### InnoDB 儲存引擎中的鎖: 表及鎖粒度粗，佔用資源少，性能差，行級鎖鎖粒度細，可以實現精準併發控制，佔用資源多。
* ### InnoDB 表級鎖
    * ### 對某表執行 SELECT、INSERT、DELETE、UPDATE 時，該表並不會被增加 IS 或 IX。
    * ### 某交易在對某表執行 ALTER TABLE、DROP TABLE 的 DDl 敘述時，其它交易對該表併發執行諸如 SELECT、INSERT、DELETE、UPDATE 時會發生阻塞。
    * ### 某交易在對表執行 SELECT、INSERT、DELETE、UPDATE 時，其它交易對該表併發執行 DDL 敘述時也會發生阻塞。
    * ### 一般情況不會使用 InnoDB 提供的表等級 S 和 X 鎖。
    * ### 基本上 InnoDB 提供的表等級 S 和 X 鎖用不太到 (特殊情況如系統崩潰復原時例外)。
    * ### 應盡量避免在 InnoDB 上使用 LOCK TABLES，本質上無法提供任何保護，而且會降低效能，也因此，我就不教如何下指令了。
* ### InnoDB 行級鎖類型
    * ### Record Lock: 只對紀錄本身加鎖。
    * ### Gap Lock: 鎖住記錄前的間隙，防止別的交易向該間隙插入新紀錄。
    * ### Next - Key Lock: 上述兩者的結合，既保護記錄本身，也防止別的交易向該間隙插入新紀錄。
    * ### Insert Intention Lock: 很雞肋的鎖，僅是為了解決在當前交易插入紀錄時因碰到別的交易加的 gap 鎖而進入等候狀態時也生成一個鎖結構而提出的，某個交易獲取一筆記錄的該類型的鎖後，不會阻止別的交易，繼續獲取該記錄上任何類型的鎖。
    * ### 隱適鎖: 依靠記錄的 trx_id 屬性來保護不被別的交易改動該記錄。
* ### InnoDB 儲存引擎的鎖都在記憶體中對應著一個鎖結構，有時為了節省鎖結構會把符合下面條件的鎖放到同一個鎖結構中。
    * ### 在同一個交易中進行加鎖操作。
    * ### 被加鎖的紀錄在同一個頁面中。
    * ### 加鎖的類型是一樣的。
    * ### 等候的狀態是一樣的。
<br />
