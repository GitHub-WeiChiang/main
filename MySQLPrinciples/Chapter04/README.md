Chapter04 從一筆記錄說起 -- InnoDB 記錄儲存結構
=====
* ### 儲存引擎: 對表中資料進行讀取和寫入 (以下皆以 InnoDB 為例)。
* ### 資料的處理位於記憶體，寫入或修改請求最終需進行刷新 (記憶體 -> 磁碟)。
* ### InnoDB 將資料劃分為 "頁" (16 KB)，以 "頁" (16 KB) 作為磁碟與記憶體互動單位。
* ### 一筆記錄，在磁碟上的存放形式稱為 "行格式" 或 "記錄格式"。
* ### 行格式: COMPACT、REDUNDANT、DYNAMIC、COMPRESSED。
* ### COMPACT 行格式
    * ### 分為 "額外資訊" 與 "真實資料"。
    * ### ("變長欄位長度列表" + "NULL 值列表" + "記錄標頭資訊") + ("列 1 值" + "列 2 值" + "..." + "列 n 值")
    * ### 變長欄位長度列表: 變長欄位 (定長欄位會補滿長度，變長欄位不會強制補滿) 資料實際佔用位元組數 (反向存放，且只儲存非 NULL 值的列之內容長度，意味著若某記錄所有的列皆非變長資料或皆為 NULL，就不會有 "變長欄位長度列表")。
    * ### NULL 值列表: 統一管理為 NULL 的列，步驟為: 統計允許 NULL 的列、如果沒有則 NULL 值列表不存在、反之將允許儲存 NULL 的列對應為一個二進位元 "反向存放"、若二進位非整數個位元組則將高位元補 0。
    * ### 記錄標頭資訊: 5 位元儲存，包含用於描述紀錄的屬性，格式為: "預留位元 1" + "預留位元 2" + "delete_flag (是否被刪除)" + "min_rec_flag (B+ 樹每層非葉子節點最小目錄項標記)" + "n_owned (組中記錄筆數，非大哥為 0)" + "heap_no (該紀錄堆積相對位置)" + "record_type (普通 -> 0、非葉子 -> 1、Infimum -> 2、Supremum -> 3)" + "next_record (下一筆記錄相對位置)"。
    * ### 真實資料: 隱藏列 + 真實資料，"row_id (行 ID，沒有 PK 才會有這列)" + "trx_id (交易 ID)" + "roll_pointer (回覆指標)" + "真實資料"。
    * ### InnoDB 主鍵生成策略: 優先使用使用者自訂主鍵，沒定義則選一個不允許為 NULL 且為 UNIQUE 的列為主鍵，再沒有則生成一個 row_id 隱藏列為主建。
    * ### 當使用 CHAR(M) 定長資料格式作為列的資料型態時，若底層編碼方式為浮動 (gbk 1\~2 位元、utf8 1\~3 位元)，一樣會被加入變長欄位長度列表。
    * ### CHAR(M) 與 VARCHAR(M) 最主要的差異為，前者會強制補滿長度至 M，後者不會，若欄位經常修改，應使用非變長欄位，避免記憶體高次數重新分配導致碎片問題。
* ### REDUNDANT 行格式: MySQL 5.0 之前就開始使用，非常的古老。
* ### 溢位列: 如果出現一個頁儲存不了一筆紀錄的情況，只會儲存部分資料於 "真實資料" 處，其餘資料將分散儲存到其它頁中，然後在 "真實資料" 處用 20 位元儲存那些 "溢位頁" 的位置等資訊，這樣我們才能找到它們。當某列需要上述操作時，將被稱為 "溢位列"。
* ### 小註解: MySQL 規定一頁中至少要有兩行記錄，我現在先不告訴你為什麼。
* ### DYNAMIC 行格式: 為 MySQL 5.7 預設行格式，與 COMPACT 行格式的差異為，"溢位列" 的所有資訊會被儲存在 "溢位頁" 中，該筆記錄的 "真實資料" 處只存放 "溢位頁" 的位置等資訊。
* ### COMPRESSED 行格式: 本質與 DYNAMIC 相同，但會採用壓縮演算法對頁面壓縮。
* ### 簡單來說
    * ### 非緊湊: REDUNDANT，原始，老，佔用儲存空間多。
    * ### 緊湊: COMPACT、DYNAMIC、COMPRESSED，新，佔用儲存空間少。
<br />
