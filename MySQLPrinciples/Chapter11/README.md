Chapter11 兩個表的親密接觸 -- 連接的原理
=====
* ### 如果連接查詢的結果集中包含一個表中的每一筆紀錄與另一個表中的每一筆紀錄相互匹配的組合，那麼這樣的結果集就可以成為 "笛卡爾乘積"。
* ### 兩張表進行合併，每張表中有三筆資料，笛卡爾乘積為 3 x 3 = 9。
* ### 連接查詢中的過濾條件
    * ### 涉及單表的條件: query 中的搜索條件限制為列與常數相比。
    * ### 涉及兩表得條件: query 中的搜索條件限制為兩表的列與列相比。
* ### 連接查詢執行過程
    * ### 確定 "驅動表" 並進行記錄的搜索 (選取代價最小的存取方法執行單表查詢)。
    * ### 將從 "驅動表" 獲取的記錄都對應至 "被驅動表"，尋找匹配記錄。
    * ### 註: 進行連接查詢時，"驅動表" 只會被存取一次，"被驅動表" 可能會被存取數次。
    * ### 註: 每獲得一筆驅動表記錄，就會立即到被驅動表中尋找匹配記錄。
* ### 內連接和外連接
    * ### 內連接的兩個表: "驅動表" 中的記錄在 "被驅動表" 中無法匹配時，"不加入" 結果集。
    * ### 外連接的兩個表: "驅動表" 中的記錄在 "被驅動表" 中無法匹配時，"仍加入" 結果集。
* ### 外連接種類
    * ### 左外連: 左側為 "驅動表"。
    * ### 右外連: 右側為 "驅動表"。
* ### 過濾條件的位置
    * ### WHERE 子句中: 不符合就不會被加入結果集。
    * ### ON 子句中: 對於外連接來說，無法在 "被驅動表" 中匹配的記錄仍會被加入到結果集並將對應 "被驅動表" 記錄的各個欄位使用 NULL 填充。
* ### ON 子句是專門為外連接驅動表中的記錄在被驅動表找不到匹配記錄時，是否應該把該驅動表記錄加入結果集中場景所提出。
* ### 如果把 ON 子句放入內連接中，那個效果等同於 WHERE 子句。
* ### 對於 "內連接" 來說，"驅動表" 和 "被驅動表" 是 "可以" 互換的。
* ### 對於 "外連接" 來說，"驅動表" 和 "被驅動表" 是 "不可以" 互換的。
* ### 巢狀結構迴圈連接
    * ### "驅動表" 只會被存取一次，"被驅動表" 可能會被存取數次。
    * ### "被驅動表" 的存取次數取決於 "驅動表" 執行單表查詢後的結果集記錄數。
    * ### 上述的執行方法稱為 "巢狀結構迴圈連接 (Nested - Loop Join)"。
    * ### 記住，在 "驅動表" 執行查詢或的的 "結果集" 只是一種抽象概念，並非蒐集完結果集才至 "被驅動表" 查詢，而是每從 "驅動表" 取得一筆記錄就立刻至 "被驅動表" 中查詢匹配記錄。
* ### 索引可以加快在 "被驅動表" 中搜索匹配記錄的速度。
* ### 盡可能不要使用 "*" 作為查詢列表，應條列真正使用到的列為查詢列表 (也就是盡可能執行 "覆蓋索引" 觸發 "索引下推")。
* ### 基於區塊的巢狀結構迴圈連接
    * ### 應盡量減少 "被驅動表" 的存取次數，降低磁碟讀取的 I/O 負擔。
    * ### Join Buffer (連接緩衝區) 可以把多筆 "驅動表" 搜尋結果暫存，使 "被驅動表" 的每一筆記錄一次性的與多筆 "驅動表" 搜尋結果將行批配，減少 I/O 負擔。
    * ### 上述做法被稱為 "基於區塊的巢狀結構迴圈連接 (Block Nested - Loop Join)" 演算法。
    * ### 在最佳化對被驅動表的查詢時，最好是為被驅動表加上高效率的索引， 如果實在不能使用索引，並且系統的記憶體足夠，則可以嘗試透過啟動選項或系統變數調大 join_buffer_size 的值來對連接查詢進行最佳化。
<br />
