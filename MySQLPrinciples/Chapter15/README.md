Chapter15 查詢最佳化的百科全書 -- EXPLAIN 詳解
=====
```
EXPLAIN SELECT ... FROM ...
```
* ### EXPLAIN 輸出列
    * ### id: 一個 SELECT 對應一個 id。
    * ### select_type: 查詢類型。
    * ### table: 表名。
    * ### partitions: 匹配的分區資訊。
    * ### type: 存取方法。
    * ### possible_keys: 可能使用索引。
    * ### key: 實際使用索引。
    * ### key_len: 實際使用索引長度。
    * ### ref: 使用索引列相等查詢時，與索引列進行相等匹配的物件資訊。
    * ### rows: 預估所需讀取的記錄筆數。
    * ### filtered: 針對 rows 經過搜索條件過濾後剩餘記錄筆數的百分比。
    * ### Extra: 額外資訊。
* ### table
    * ### EXPLAIN 敘述輸出的每一筆記錄都對應著某個表單的存取方法，table 當然就是表的名稱嘍。
* ### id
    * ### 查詢中，一個 SELECT 會被分配一個唯一的 id 值。
    * ### 假設 SELECT 關鍵字後的 FORM 子句有多張表，每一張表會對應一筆記錄，但這些記錄的 id 值都是相同的。
    * ### 若查詢敘述包含子查詢，但執行計畫中的記錄 id 值都是 1，代表該子查詢被最佳化工具轉為連接查詢。
    * ### 如果 id 值為 NULL，表示出現了為合併兩個查詢結果集而創建臨時表的操作。
* ### select_type (詳細內容參閱書籍 15-8 頁)
    * ### 一個查詢敘述可以包含多個 SELECT 關鍵字。
    * ### 每個 SELECT 關鍵字都代表著一個小的查詢敘述。
    * ### 每個 SELECT 子句都可以包含多張表。
    * ### 每張表對應著執行計畫輸出的一筆記錄。
    * ### 同一個 SELECT 關鍵字中的表對應之記錄 id 值是相同的。
    * ### 來看看 select_type 有哪些 type 吧。
    * ### SIMPLE: 查詢敘述中不包含 UNION 或子查詢都算是此類型。
    * ### PRIMARY: 包含 UNION、UNION ALL 或子查詢的大查詢來說，它是由幾個小查詢組成，最左邊的 (外層) 查詢就是此類型。
    * ### UNION: 包含 UNION、UNION ALL 或子查詢的大查詢來說，它是由幾個小查詢組成，除了最左邊的 (外層) 查詢，其餘查詢都是此類型。
    * ### UNION RESULT: 當 MySQL 使用臨時表完成 UNION 查詢的去重工作，針對臨時表的查詢就是此類型。
    * ### SUBQUERY: 如果包含子查詢的查詢敘述不能夠轉為對應的半連接形式，並且該子查詢是不相關子查詢，而且查詢最佳化工具決定採用將該子查詢物化的方案來執行該子查詢時，該子查詢的第一個 SELECT 關鍵字代表的那個查詢就是此類別。
    * ### DEPENDENT SUBQUERY: 包含子查詢的查詢敘述不能夠轉為對應的半連接形式，並且該子查詢被查詢最佳化工具轉為相關子查詢的形式，則該子查詢的第一個 SELECT 關鍵字代表的那個查詢就是此類。
    * ### DEPENDENT UNION: 包含 UNION 或 UNION ALL 的大查詢中， 如果各個小查詢都依賴與外層查詢，則除了左邊的那個小查詢之外，其餘的小查詢都是此類。
    * ### DERIVED: 在包含延伸表的查詢中，如果是以物化衍生表的方式執行查詢，則衍生表對應的子查詢就是此類。
    * ### MATERIALIZED: 當查詢最佳化工具在執行包含子查詢的敘述時，選擇將子查詢物化之後與外層查詢進行連接查詢，該子查詢就是此類。
* ### type
    * ### 執行計劃的一筆紀錄代表著 MySQL 對某個表執行查詢時的存取方法。
    * ### 來看看 type 有哪些 type... 吧。
    * ### system: 表中只有一筆記錄，且該表使用的儲存引擎統計資料是精確的 (MyISAM、MEMORY)。
    * ### const: 根據主鍵和唯一二級索引列與常數進行相等匹配時的存取方法。
    * ### eq_ref: 執行連接查詢時，如果被驅動表是透過主鍵或不允許儲存 NULL 值的唯一二級索引列相等匹配的方式進行存取，為此存取方法。
    * ### ref: 當透過普通的二級索引列與常數進行相等匹配的方式來查詢某個表時，為此存取方法。
    * ### fulltext: 全文索引。
    * ### ref_or_null: 當對普通二級索引列進行相等匹配，且該索引列的值也可以是 NUll 時為此存取方法。
    * ### index_merge: 使用合併索引方式執行查詢，為此存取方法。
    * ### unique_subquery: 針對包含 IN 子查詢的查詢敘述，如果最佳化工具決定將 IN 子查詢轉為 EXISTS 子查詢，且子查詢在轉換後可以使用主鍵或不允許儲存 NULL 值的唯一二級索引進行相等匹配。
    * ### index_subquery: 與 unique_subquery 類似，只不過在存取子查詢中的表時使用的是普通的索引。
    * ### range: 如果使用索引獲取某些單點掃描區間的紀錄或用於獲取某個或某些範圍掃描區間的記錄，為此存取方法。
    * ### index: 當可以使用索引覆蓋但需要掃描全部的索引記錄時，為此存取方法 (當需要執行全資料表掃描並且需要對主鍵進行排序時也是此方法)。
    * ### ALL: 全資料表掃描。
* ### possible_keys 與 key
    * ### possible_keys 並不是越多越好，possible_keys 越多意味著查詢最佳化工具的分析成本越高，所以應該儘量刪除那些用不到的索引。
* ### key_len (詳細內容請參閱書籍 15-16 頁)
    * ### 由三部分組成
        * ### 該列實際資料最多佔用的儲存空間長度。
        * ### 如果可以儲存 NULL 值，再加上 1。
        * ### 使用變長類型，再加上 2。
    * ### 此欄位主要是為了讓使用者在使用聯合索引執行查詢時，能知道最佳化器具體使用了涉及多少個列的搜索條件來充當形成掃描區間的邊界條件。
* ### ref
    * ### 展示與索引列相等匹配的東西是什麼。
    * ### const 表示常數。
    * ### 也可能直接顯示某一個列，格式為 "db_name.table_name.row_name"。
    * ### 還有可能是 func (函數)。
* ### rows
    * ### 預計掃描的索引記錄數。
* ### filtered (詳細內容請參閱書籍 15-20 頁)
    * ### MySQL 在計算驅動表扇出時採用的策略。
    * ### 如果使用全資料表掃描的方式來執行單表查詢，那麼計算驅動表扇出時需要估計出滿足全部搜索條件的紀錄到底有多少筆。
    * ### 如果使用索引來執行單資料表掃描，那麼計算驅動表扇出時需要估計出在滿足形成索引掃描區間的搜索條件外，還滿足其他搜索條件的紀錄有多少筆。
* ### Extra (用於說明一些額外資訊，詳細內容請參閱書籍 15-21 頁)
    * ### No tables used: 查詢敘述中沒有 FORM 子句。
    * ### Impossible WHERE: 查詢敘述中 WHERE 子句永遠為 FALSE。
    * ### No matching min / max row: 查詢清單處有 MIN 或 MAX 聚集函數，但是並沒有記錄符合 WHERE 子句中的搜索條件。
    * ### Using index: 使用覆蓋索引進行查詢。
    * ### Using index condition: 搜索條件中出現索引列但不能充當邊界條件來形成掃描區間 (不能用來減少需要掃描的記錄數量)。
    * ### Using where: 當某個搜索條件需要在 server 層進行判斷。
    * ### Using join buffer (Block Nested Loop): 在連接查詢的執行過程中，被驅動表不能有效地利用索引加快存取速度時，MySQL 一般會為其分配一塊名為連接緩衝區 (Join BUffer) 的區快來加快查詢速度，也就是基於區塊的巢狀結構迴圈演算法來執行連接查詢。
    * ### Using intersect() / Using union() / Using sort_union(): 使用了 Intersection、Union 或 Sort - Union 方式執行查詢。
    * ### Zero limit: 當 LIMIT 子句參數為 0 時。
    * ### Using filesort: 對結果集中的記錄進行排序時，是可以使用到索引的，
    * ### Using temporary: 執行過程中 MySQL 借助臨時表完成一些功能 (去重、排序等)。
    * ### Start temporary / End temporary: 當子查詢轉為半連接執行方法為 Duplicate Weedout 時，驅動表為 Start temporary，被驅動表為 End temporary。
    * ### LooseScan: 子查詢轉為半連接執行方法為 LooseScan 時。
    * ### FirstMatch(table_name): 子查詢轉為半連接執行方法為 FirstMatch 時。
* ### Json 格式的執行計畫 (詳細內容請查閱書籍 15-29 頁)
    ```
    EXPLAIN FORMAT=JSON SELECT ... FROM ...
    ```
    * ### read_cost 由以下兩部分組成
    ```
    read_cost = I/O 成本 + (檢測 rows x (1 - filter) 筆記錄的 CPU 成本)
    ```
    * ### eval_cost 計算方式
    ```
    eval_cost = 檢測 rows x filter 筆記錄的成本
    ```
    * ### prefix_cost 就是單獨查詢某表的成本，也就是 read_cost + eval_cost。
* ### 可以透過指令 ```SHOW WARNINGS``` 近一步查看執行計畫擴充資訊 (詳細內容請查閱書籍 15-32 頁)。
<br />
