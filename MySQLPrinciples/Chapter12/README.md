Chapter12 誰最便宜就選誰 -- 基於成本的最佳化
=====
* ### MySQL 的執行成本
    * ### I/O 成本: 從磁碟到記憶體的載入過程損耗時間。
    * ### CPU 成本: 讀取記憶體與檢測記錄是否滿足搜索條件、對結果集進行排序等操作損耗的時間。
* ### MySQL 成本常數定義
    * ### 讀取一個頁面的成本: 1.0。
    * ### 讀取並檢測一筆記錄是否符合搜索條件的成本: 0.2。
    * ### 註: 即使不需要檢測記錄是否符合搜索條件，成本還是 0.2。
* ### 基於成本的最佳化步驟 (單表查詢)
    * ### 執行一筆單表查詢敘述，MySQL 最佳化器會找出所有可以用來執行該敘述的方案並篩選出成本最低的方案，此方案稱為 "執行計畫"。
    * ### 過程如下
        * ### 根據搜索條件找出可能使用的索引。
        * ### 計算全資料表掃描的代價。
        * ### 計算各個可用索引的代價。
        * ### 比較並找出成本最低的方案。
    * ### 在一個查詢中，可能使用到的索引稱為 possible keys。
    * ### 全資料表掃描的意思就是把聚簇索引中的記錄都依次與指定的搜索條件進行比較，並把符合搜索條件的記錄加入到結果集中 (所以需要將聚簇索引對應的頁面載入到記憶體中，然後再檢測記錄是否符合搜索條件)。
    * ### 查詢成本 = I/O 成本 + CPU 成本
    * ### 全資料表掃描代價計算所需資訊: "聚簇索引佔用頁面數" 與 "該表中的記錄數"。
    * ### 透過 ```SHOW TABLE STATUS LIKE 'table name'``` 查看表統計資訊。
        * ### Rows 選項: 表中記錄筆數，對於 MyISAM 來說這是一個精確值，對於 InnoDB 來說這是一個估計值。
        * ### Data_length 選項: 表佔用的儲存空間位元組數，對於 MyISAM 來說這是資料檔案的大小，對於 InnoDB 來說這是據促索引佔用的儲存空間大小。
        * ### InnoDB Data_length 計算公式:
        ```
        Data_length = 聚簇索引的頁面數量 x 每個頁面的大小 (16 KB)
        ```
        * ### 反向推導聚簇索引頁面數量:
        ```
        聚簇索引的頁面數量 = Data_length / 16 / 1024
        ```
        * ### 當頁數為 97 且筆數為 9693 時，成本計算過程為:
        ```
        I/O 成本 = 97 x 1.0 + 1.1 (這是一個微調數值) = 98.1

        CPU 成本 = 9693 x 0.2 + 1.0 (這也是一個微調數值) = 1939.6

        總成本 = 98.1 + 1939.6 = 2037.7
        ```
        * ### 雖然執行全資料表掃描時，並不會存取內節點，但它們還是會被納入成本計算中。
* ### "二級索引" + "回表" 的查詢成本計算
    * ### 依賴兩方面資料: 掃描區間數量 + 需要回表的記錄數。
    * ### 掃描區間數量
        * ### 定義: 讀取索引的掃描區間之 I/O 成本與讀取一個頁面的 I/O 成本是相同的，讀取一個掃描區間成本為 1，讀取三個掃描區間成本為 3。
        * ### 存取一個掃描區間的二級索引所付出的 I/O 成本為 1 x 1.0 = 1.0。
    * ### 需要回表的記錄數
        * ### 當左右記錄距離不超過 10 個頁面，遍歷求取比數 (加總頁面 PAGE_N_RECS 屬性值)。
        * ### 否則只從左記錄開始向右讀取 10 個頁面，計算每個頁面平均包含多少記錄，後將此平均值乘以左右記錄之間的頁面數量 (透過頁面對應的目錄，也就是內節點進行計算，如果比數真的很多導致目錄項都跨頁面，那就遞迴在往上一層)。
    * ### 讀取 95 筆二級索引記錄時，成本計算過程為:
    ```
    CPU 成本 = 95 x 0.2 + 0.01 (這又是一個微調數值) = 19.01
    ```
    * ### 每一次的回表操作成本相當於存取一個頁面。
    * ### 執行 95 次回表操作時，成本計算過程為:
    ```
    I/O 成本 = 95 x 1.0 = 95.0
    ```
    * ### 執行 95 次回表操作後讀取並檢測是否符合級於搜索條件時，成本計算過程為:
    ```
    CPU 成本 = 95 x 0.2 = 19.0
    ```
    * ### 綜合上述，總成本為:
    ```
    I/O 成本 = 1.0 + 95 x 1.0 = 96.0

    CPU 成本 = (95 x 0.2 + 0.01) + (95 x 0.2) = 38.01

    總成本 = 96.0 + 38.01 = 134.01
    ```
* ### 多掃描區間成本計算案例
    * ### 3 個單點掃描區間成本為:
    ```
    I/O 成本 = 3 x 1.0 = 3.0
    ```
    * ### 計算各個掃描區間的回表 (記錄) 次數 (計算方法與前述相同)
    * ### 假設三個單點掃描區間回表 (記錄) 筆數分別為 35、44、39 (總和為 118)。
    * ### 讀取二級索引記錄成本:
    ```
    CPU 成本 = 118 x 0.2 + 0.01 = 23.61
    ```
    * ### 回表操作成本為:
    ```
    I/O 成本 = 118 x 1.0 (一筆回表一頁計) = 118.0
    ```
    * ### 比較其它搜索條件是否成立成本為:
    ```
    CPU 成本 = 118 x 0.2 = 23.6
    ```
    * ### 綜合上述，總成本為:
    ```
    I/O 成本 = 3.0 + (118 x 1.0) = 121.0

    CPU 成本 = (118 x 0.2 + 0.01) + (118 x 0.2) = 47.21

    總成本 = 121.0 + 47.21 = 168.21
    ```
* ### 最後比較各種執行方案的代價，找出成本最低的那個方案之索引進行查詢。
* ### 基於索引統計資料的成本計算
    * ### 還記得記錄數的估算方法嗎 (就是那個什麼十頁什麼精確和不精確的東東) ? 在 MySQL 中透過直接存取索引對應的 B+ 樹來計算某個掃描區間內對應的索引記錄筆數，這種方法稱為 "index dive"。
    * ### 如果單點掃描的區間數量太多，"index dive" 的執行對性能會有可觀的消耗，所以 MySQL 提供了系統變數 "eq_range_index_dive_limit"，預設為 200，當單點掃描區間數量小於 200 將觸發 "index dive"，若大於 200 則使用索引統計資料 (index statistics) 進行估算。
    * ### 透過 ```SHOW INDEX FROM table_name``` 查看索引統計資料 (詳細內容請查閱書籍 12-15 頁)
        * ### Cardinality 欄位: 表示某個列不重複的值的個數，若為 1 表示所有列的值是重複的，不過這傢伙也是一個估計值。
        * ### 結合透過指令 ```SHOW TABLE STATUS``` 取得的 Rows 值，可以計算出某一個列中一個值平均的重複次數，公式如下:
        ```
        一個值平均的重複次數 (估計值) = Rows / Cardinality
        ```
    * ### 當 Rows 為 9693，某被使用於搜索條件的索引列 Cardinality 為 968，該列單一值的平均重複次數為 9693 / 968，大約為 10 筆。
    * ### 假設某查詢對應 20000 個單點掃描區間，計算筆數將為 20000 x 10 = 200000。
* ### 連接查詢的成本
    * ### 條件過濾 (Condition Filtering)
        * ### 查詢成本組成: 單次查詢驅動表的成本 + 多次查詢被驅動表的成本。
        * ### 查詢驅動表後得到的記錄筆數稱為驅動表的扇出 (fanout)。
        * ### 扇出值越小，被驅動表查詢次數越少，連接查詢成本越低。
        * ### 詳細計算範例請查閱書籍 12-18 頁。
    * ### 在以下兩種情況，扇出值要用猜的:
        * ### 如果使用全資料表掃描的方式執行單表查詢，那麼計算驅動表單扇出時所需要猜測滿足全部搜索條件的記錄到底有多少筆。
        * ### 如果使用索引來執行單表查詢 那麼計算驅動表單扇出時需要猜測除了滿足形成索引掃描區間的搜索條件外， 還滿足其它搜索條件的記錄有多少筆。
        * ### MySQL 5.7 之前沒在猜，全資料表掃描直接用表中記錄數量作為扇出值，若為索引掃描則以掃描區間的筆數作為扇出值。
        * ### MySQL 5.7 之後開始猜，透過啟發式 (heuristic) 規則瞎猜，跟你考試的時候一樣。
* ### 兩表連接的成本分析
    * ### 公式為:
    ```
    連接查詢總成本 = 單次存取驅動表的成本 + (驅動表扇出值 x 單次存取被驅動表的成本)
    ```
    * ### 對外連結來說，驅動表就是驅動表，沒啥好說，計算成本，找最低成本存取方法，設為最佳查詢方案。
    * ### 對內連結來說，因為驅動表與被驅動表可以互換，所以要考慮最佳的表連接順序。
    * ### 詳細計算方式請查閱書籍 12-21 頁。
    * ### 總之，最佳化查詢的重點為:
        * ### 儘量減少驅動表的扇出。
        * ### 存取被驅動表的成本要儘量低: 簡單說就是，被驅動表的連接列最好是該表的主鍵或唯一二級索引列，如此可以把存取被驅動表的成本降至更低。
* ### 多表連接成本分析
    * ### 連接順序種類數量: n 張表的連接數量為 n!。
    * ### 計算每種可能的成本，但透過了一些方法提升計算性能。
        * ### 提前結束某種連接順序的成本評估: 當前分析成本加總已大於當前最低成本記錄時，停止此種連接順序分析。
        * ### 系統變數 optimizer_search_depth: 當連接表個數小於此值，窮舉分析每一種連接可能的成本，否則只對數量與 optimizer_search_depth 相同的表進行分析 (當然結果就不是精確值了)。
        * ### 某些規則根本就不考慮某些連結順序: MySQL 工程師提出了一些啟發式規則 (根據以往經驗所訂定出來的)，不滿足這些規則的表連接順序直接不分析，極大降低分析數量，當然也可能錯殺無辜，可以透過系統變數 optimizer_prune_level 控制是否啟用。
* ### 調節成本常數
    * ### 執行一行敘述時，分為 server 層和儲存引擎層。
    * ### server 層: 進行連接管理、快取查詢、語法解析、查詢最佳化等。
    * ### 儲存引擎層: 執行具體資料存取操作。
    * ### server 層操作對應成本儲存在 server_cost 表中。
    * ### 儲存引擎層操作對應成本儲存在 engine_cost 表中。
    * ### server_cost 成本常數
        * ### disk_temptable_create_cost: 預設值 40，為創建基於磁碟的臨時表成本，增大則會盡可能少去創建基於磁碟的臨時表。
        * ### disk_temptable_row_cost: 預設值 1，為基於磁碟臨時表寫入或讀取一筆記錄成本，增大則會盡可能少去創建基於磁碟的臨時表。
        * ### key_cimpare_cost: 預設值 0.1，為兩筆記錄比較成本，增大會使最佳化工具更傾向使用索引進行排序而非 filesort。
        * ### memory_temptable_create_cost: 預設值 2，為基於記憶體的臨時表成本，增大則會盡可能少去創建基於記憶體的臨時表。
        * ### memory_temptable_row_cost: 預設值 0.2，為基於記憶體臨時表寫入或讀取一筆記錄成本，增大則會盡可能少去創建基於記憶體的臨時表。
        * ### row_evaluate_cost: 預設值 0.2，讀取並檢測一筆記錄是否符合搜索條件的成本，增大則使最佳化查詢工具更傾向使用索引查詢而非全資料表掃描。
        ```
        # 查詢方式
        SELECT * FROM mysql.server_cost;

        # 修改方式
        UPDATE mysql.server_cost
        SET cost_value = custom_cost_value
        WHERE cost_name = 'cost_name';

        # 套用
        FLUSH OPTIMIZER_COSTS;

        # 恢復預設
        UPDATE mysql.server_cost
        SET cost_value = NULL
        WHERE cost_name = 'cost_name';
        ```
    * ### engine_cost
        * ### 多了兩個列: engine_name (適用的引擎)、device_type (是機械硬碟還是固態硬碟)。
        * ### 成本常數 io_block_read_cost: 預設值 1，為從磁碟上讀取一個區塊對應的成本。
        * ### 成本常數 memory_block_read_cost: 預設值 1，為 從記憶體中讀取一個區塊對應的成本。
        * ### 都是 1，因為 MySQL 目前不能準確預測某個查詢需要存取的區塊有哪些已經載入到記憶體有哪些還在磁碟上。
        ```
        # 查詢方式
        SELECT * FROM mysql.engine_cost;

        # 插入針對某個儲存引擎的成本常數
        INSERT INTO mysql.engine_cost
        VALUES ('InnoDB', 0, 'io_block_read_cost', 2.0, CURRENT_TIMESTAMP, 'increase InnoDB I/O cost')

        # 套用
        FLUSH OPTIMIZER_COSTS;
        ```
<br />
