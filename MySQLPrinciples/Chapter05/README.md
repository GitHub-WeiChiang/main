Chapter05 盛放記錄的大盒子 -- InnoDB 資料頁結構
=====
* ### "頁" 是 InnoDB 管理儲存空間的基本單位，一頁是 16 KB。
* ### "頁" 的類型: 表格空間表頭資訊頁、Change Buffer 資訊頁、INODE 資訊頁、undo 記錄檔資訊頁等。
* ### 存放表中記錄的頁稱為 Index (索引) 頁，也可以叫做資料頁啦。
* ### 資料頁的空間劃分
    * ### File Header: 頁的通用資訊。
    * ### Page Header: 資料頁專有資訊。
    * ### Infimum + Supremum: 虛擬記錄。
    * ### User Records: 使用者記錄。
    * ### Free Space: 尚未使用空間。
    * ### Page Directory: 某些紀錄的相對位置。
    * ### File Trailer: 驗證完整性用。
* ### 插入記錄時，從 Free Space 申請一筆記錄的空間，劃分至 User Records，當 Free Space 都成為 User Records 時，代表這個頁面滿了，需申請新頁面。
* ### 複習 COMPACT 行格式的 "記錄標頭資訊"
    * ### 預留位元 1
    * ### 預留位元 2
    * ### delete_flag (是否被刪除)
        * ### 未刪除 -> 0
        * ### 已刪除 -> 1
    * ### min_rec_flag (B+ 樹每層非葉子節點最小目錄項標記)
    * ### n_owned (組中記錄筆數，非大哥為 0)
    * ### heap_no (該紀錄堆積相對位置)
    * ### record_type
        * ### 普通記錄 -> 0
        * ### 非葉子頁的記錄 -> 1
        * ### Infimum -> 2
        * ### Supremum -> 3
    * ### next_record (下一筆記錄相對位置)
* ### delete_flag: 表示記錄是否被刪除，這不是真的刪除，只是一個標記，避免刪除操作的性能消耗，被刪除的記錄會組成一個垃圾鏈結串列，成為可重用空間，新紀錄就可能覆蓋掉這些垃圾。
* ### min_rec_flag: B+ 樹每層非葉子節點中的最小目錄項紀錄都會增加此標記，不懂對不對，先這樣吧。
* ### n_owned: 我調皮，我不說。
* ### heap_no: 記錄在資料頁的 User Records 中被一筆一筆緊密的排列，稱之為堆積 (heap)，而某筆記錄在堆積中的相對位置，稱為 heap_no，越前面越小，反之越大，以 1 遞增，從 2 開始。
* ### 為什麼 heap_no 中的真實記錄從 2 開始 ? 因為有兩筆預設的虛擬記錄 (Infimum + Supremum)，分別代表當頁最小 (Infimum) 與最大 (Supremum) 紀錄。
    * ### Infimum 的 heap_no 為 0。
    * ### Supremum 的 heap_no 為 1。
* ### 記錄的大小比較是透過主鍵，且任何使用者記錄都大於 Infimum，並任何使用者記錄都小於 Supremum。
* ### heap_no 在分配後就不會被更動，hen 重要。
* ### record_type
    * ### 0: 普通記錄。
    * ### 1: B+ 樹非葉子節點的目錄項紀錄。
    * ### 2: Infimum。
    * ### 3: Supremum。
* ### next_record: 當前記錄的真實資料到下一筆記錄的真實資料的距離。
    * ### 正數: 下一筆記錄在後面。
    * ### 負數: 下一筆記錄在前面。
    * ### 就是所謂的 "單向鏈結串列" 啦。
    * ### 下一筆記錄是按照主鍵由小到大順序排列，不是插入順序呦。
    * ### Infimum 的下一筆記錄就是本頁最小的記錄。
    * ### 本頁最大的記錄的下一筆記錄就是 Supremum。
* ### next_record 指向 "額外資訊" 與 "真實資料" 之間的位置，因為這樣只要或是說就可以透過 "左右開弓似射鵰"，快速讀取對應資訊，提高快取記憶體的命中率，這也是為什麼 "變長欄位長度列表" 與 "NULL 值列表" 要反向存放的原因。
* ### Page Directory (頁目錄)
    * ### 製作過程
        * ### 將所有未刪除記錄 (包含 Infimum + Supremum) 劃分成幾個組。
        * ### 每組最後一筆紀錄 (最大那個) 將作為大哥帶領剩餘小弟，並於 n_owned 中表示該組內有多少記錄。
        * ### 每組中最後一筆記錄在頁面中的位址偏移量按序 (slot_0, slot_1, ..., slot_n) 存放於頁尾部，也就是 Page Directory。
        * ### Page Directory 中用的偏移量稱為 slot (槽)，所以 "頁目錄" 是由一堆 "槽" 組成。
    * ### 劃分分組的依據
        * ### Infimum 自己一個人一組，跟我大學同學一樣 QQ。
        * ### Supremum 在的組筆數限制為 1~8。
        * ### 其餘組筆數限制為 4~8。
    * ### 初始情況下一個頁面有兩個組 (Infimum + Supremum)，即兩個槽。
    * ### 每插入一筆記錄，從 Page Directory 中找到主鍵比待插入記錄大並且差值最小的槽，然後把該槽對應的 n_owned 加一，直到等於 8 為止。
    * ### n_owned 等於 8 後，該組會被拆分為一組 4 筆與一組 5 筆的兩個組，並在 Page Directory 新增一個槽記錄位址。
* ### 搜尋資料時 (透過主鍵)
    * ### 在 Page Directory 採用 "二分搜尋"。
    * ### 在組中採用 "迭代遍歷"。
    * ### 如何找到組的最小記錄，也就是第一筆紀錄 (畢竟 Page Directory 裡的槽是指向組的老大) ? 那你就去前一個槽找到那個老大的後一筆記錄就是勒。
* ### Page Header (頁面表頭): 存放狀態資訊，例如總筆數、Free Space 頁面位址偏移量、槽數等。
* ### File Header (檔案表頭): 頁通用資訊，例如頁編號、上一頁是誰 (FIL_PAGE_PREV)、下一頁又是誰 (FIL_PAGE_NEXT) 等。
* ### 資料頁 (索引頁) 就是透過 FIL_PAGE_PREV 與 FIL_PAGE_NEXT 形成 "雙向鏈結串列" (物理上不必一定緊密相連，且非所有類型頁都能串接成雙向鏈結串列)。
* ### File Trailer (檔案結尾)
    * ### 資料以頁為單位載入至記憶體，或遭修改，會在後續某一時間被刷新磁碟中。
    * ### 停電怎辦 ? 下班啊 !
    * ### 前四位元組為 "校正碼 (CHECKSUM)"，與 File Header 中的校正碼對應，刷新成功頭尾一致，反之失敗。
    * ### 後四位元: 先不管，反正也是用於頁面完整性驗證。
    * ### File Trailer 也是頁通用資訊呦。
<br />
