SpringBoot
=====
* ### Chapter03 使用開發工具
* ### Chapter04 Spring Boot 基礎
* ### Chapter05 分層開發 Web 應用程式
* ### Chapter06 響應式程式設計
* ### Chapter07 Spring Boot 進階
* ### Chapter08 用 ORM 操作 SQL 資料庫
* ### 其它
	* ### RESTful API
	* ### JWT
		* ### header
		* ### payload
		* ### signature
	* ### Redis
		* ### 數據一致性: 資料庫與快取間雙重寫入數據一致性問題。
		* ### 快取穿透: 訪問一個不存在的 key，快取不起作用，請求會穿透到 DB，流量大時 DB 會掛掉。
		* ### 快取雪崩: 快取因高峰請求當機，所有請求直接轉向資料庫導致資料庫故障，即便重啟又馬上故障。
		* ### 快取擊穿: 某 key 訪問頻繁，處於集中式高併發訪問的情況，當這個 key 在失效的瞬間，大量的請求就擊穿了快取，直接請求資料庫。
		* ### 快取平行處理競爭問題。
		* ### 為甚麼比較快: 純記憶體操作、單執行續操作、非阻塞 I/O 多工機制。
		* ### 可用於高平行處裡讀寫、計數器、排行榜、分散式階段、互動場景與最新列表。
		* ### ![image](https://raw.githubusercontent.com/GitHub-WeiChiang/main/master/SpringBoot/%E7%B7%A9%E5%AD%98%E7%95%B0%E5%B8%B8%E5%A0%B4%E6%99%AF.jpg)
	* ### Memcached
		* ### 以 Libenevt 為基礎的事件處裡，內建記憶體儲存方式。
		* ### 分散式不互相通訊。
		* ### 不會對資料進行持久化。
		* ### 重啟 Memcached 或作業系統都會導致全部資料消失。
		* ### 可用於儲存讀取頻繁但更新較少的資料 (靜態網頁、系統組太、規則資料、活耀使用者基本資料、個性化訂製資料與即時統計等)。
	* ### Redis vs Memcached
		* ### 關注度: Redis。
		* ### 效能: 平手。
		* ### 資料類型: Redis 豐富、Memcached 單一。
		* ### 記憶體大小: Redis 的 VM 特性突破實體記憶體限制、Memcached 採用 LRU 演算法修改最大可用記憶體大小。
		* ### 可用性: Redis 依賴用戶端實現分散式讀寫並不支援自動分片 (sharding) 功能 (要實現需依賴程式設定一致雜湊機制)、Memcached 採用成熟 hash 或環狀算法解決單點故障引起抖動問題 (本身沒有資料容錯機制)。
		* ### 持久化: Redis 依賴快照、AOF 進行持久化 (但對效能有所影響)、Memcached 不支援持久化 (通常用於快取以提高效能)。
		* ### value 資料大小: Redis 1 GB、Memcached 1 MB。
		* ### 資料一致性: Redis 只能保障交易中每個操作連續執行、Memcached 在平行處裡場景下用 CAS 保障一致性。
		* ### 應用場景: Redis (資料量少但效能操作和運算要求高)、Memcached (提升效能與讀多寫少，若資料量大可採用分片方式解決)。
	* ### redis 的 VM (虛擬記憶體) 機制: 將不經常訪問的資料 (冷資料) 從記憶體交換到磁碟中，從而騰出寶貴的記憶體空間用於其它需要訪問的資料 (熱資料)。
	* ### Redis 分片機制實現概念: 將不同 key 映射到不同 Redis 實例上存儲。
		* ### 範圍分片。
		* ### 哈希分片。
	* ### 單點故障 (single point of failure，縮寫 SPOF) 是指系統中一旦失效，就會讓整個系統無法運作的部件，換句話說，單點故障即會整體故障。
	* ### CAS (Compare and Swap) 機制: 因為多核 CPU 的存在，總是需要保障程序高性能的利用計算機的 CPU 資源，並要保障計算結果與預期的一致。因此常用的方式就是加鎖方式。就是佔用 -> 佔用結束 -> 釋放的過程，在此過程中不允許其他線程來操作已經佔用的計算機資源。
	* ### Redis RDB 持久化: 生成指定時間間隔內的 Redis 內存中數據快照，是一個二進位文件 dumpr.rdb。
	* ### Redis AOF 持久化: 記錄 Redis 除了查詢以外的所有寫命令，並在 Redis 服務啟動時，通過重新執行這些命令來還原數據 (默認關閉)。
	* ### RabbitMQ
		* ### 消息隊列。
		* ### 解耦、異步、削峰。
	* ### Elasticsearch: 搜尋和資料分析引擎。
	* ### PUT: 提交完整需更新物件。
	* ### PATCH: 對已知資源進行局部更新。
	* ### GET 與 POST 區別
		* ### GET 在瀏覽器中可以回退，POST 造訪同一位址時只是再次提交請求。
		* ### GET 會被瀏覽器快取，POST 不會。
		* ### GET 中的參數會被完整保留於瀏覽器歷史紀錄，POST 不會。
		* ### GET 只能進行 URL 編碼，POST 支援多種編碼方式。
		* ### GET 只接收 ASCII 字元，POST 無限制。
		* ### GET 安全性相較於 POST 低，因其參數暴露在 URL 上，不可用於傳遞敏感資訊。
		* ### GET 參數透過 URL 傳遞，POST 存放於 request body 中。
<br />

Reference
=====
* ### 極速開發 Java 大型系統：Spring Boot 又輕又快又好學
