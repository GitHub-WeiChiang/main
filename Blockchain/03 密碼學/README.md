密碼學
=====
3.1 加密與解密
-----
* ### 編碼的過程即加密的過程，加密模塊把可讀信息(明文)處理成代碼形式(密文)。
* ### 解碼的過程即解密的過程，解密模塊把代碼形式(密文)轉換回可讀信息(明文)。
* ### 加解密過程中，密鑰為關鍵角色。
* ### 加密技術: 對稱加密、不對稱加密、不可逆加密。
	* ### 對稱加密: 早期加密算法，加解密密鑰相同，對稱密鑰技術基本類型為分組密碼和序列密碼。
		* ### 算法公開、計算量小、加密速度快、加密效率高。
		* ### 交易雙方使用相同密鑰、安全性無保證。
		* ### 廣泛使用的對稱加密算法: DES、3DES、IDEA、AES(取代DES)
	* ### 不對稱加密: 使用兩把完全不同但又完全匹配的一對鑰匙，即公鑰與私鑰。
		* ### RSA 算法、DSA 算法。
		* ### 數位簽章(Digital Signature)以不對稱加密算法為基礎。
		* ### 安全性高、加密速度慢、效率低。
	* ### 不可逆加密: 加密過程無需密鑰，輸入明文後由系統直接經過加密算法處理成密文，加密後的數據無法解密，必須重新輸入密文，並再次經過相同不可逆加密算法處理，若得到相同加密密文並被系統重新識別，才能真正解密。
		* ### RSA 算法、MD5 算法、SHS 算法。
* ### Java 實現
	* ### Cipher
		* ### Java 原生 API 實現。
		* ### Cipher 提供加密和解密功能。
		* ### 聲明為 public class Cipher extends Object。
		* ### 構成 Java Cryptographic Extension (JCE) 框架核心。
		* ### 使用時，構建 Cipher 再調用 Cipher 的 getInstance 方法來實現，由用戶自定義傳參，在 Cipher 中稱之為"轉換"，"轉換"用於描述生成對象使用的算法。
	* ### Hutool
		* ### 第三方工具包。
		* ### 更好的封裝工具，簡化開發。
	* ### Tink
		* ### 第三方工具包。
		* ### 由 Google 的一群密碼學家和安全工程師編寫的密碼庫。
		* ### 顯著減少開發中常見的密碼陷阱。
		* ### 原語在 Tink 中指的是加密操作，其構成 Tink API 的核心。
		* ### 原語是一個接口，它指定了原語能提供的基本操作。
		* ### 一個原語可以有多個實現。
		* ### 用戶可以通過使用某種類型的鍵來設定想要的實現。
		* ### 不要使用標有 \@Alpha 注釋的字段和方法 API，因其可以以任何方式修改與刪除，其主要功用為測試。
		* ### 不要再 com.google.crypto.tink.subtle 上使用 API，雖然其 API 是安全的，但其可隨時以任何方式修改甚至是刪除。
3.2 哈希
-----
* ### 哈希函數，亦稱為散列函數或雜湊函數。
* ### 散列函數簡介
	* ### 可以將任意大小的數據映射到固定大小數據的任何函數。
	* ### 返回值稱為散列函數、哈希代碼、摘要或簡單散列。
	* ### 通常與哈希表配合使用，哈希表是計算機軟件中用于快速查找數據的常用數據結構。
	* ### 單向密碼體制，即一個從明文到密文的不可逆映射，只有加密，沒有解密。
* ### 散列函數特點
	* ### 壓縮性強: 對于任意大小的輸入內容，哈希值的長度很小，而且長度是固定位數的。
	* ### 計算簡單: 對于任意給定的消息，計算其哈希值都比較簡單。
	* ### 計算結果單向性: 無法倒推輸入的原始數據，這也是散列函數安全性的重要基礎。
	* ### 需注意抗碰撞性。
* ### 哈希算法
	* ### MD (Message Digest, 消息摘要)
		* ### MD4
		* ### MD5
		* ### HAVAL
	* ### SHA (Secure Hash Algorithm, 安全散列)
		* ### SHA1
		* ### SHA256
* ### 常見哈希算法
	* ### SHA - 1
		* ### 輸入最大長度小於 264 bit
		* ### 輸入以 512 bit 的分組為單位進行處理
		* ### 輸出是 160 bit 的消息摘要
		* ### 實現速度高、容易被實現與應用範圍廣等優點。
	* ### SHA - 2
		* ### 輸出長度可取 224 bit、256 bit、384 bit、512 bit，分別對應 SHA - 224、SHA - 256、SHA - 384、SHA - 512。
		* ### 其還包含兩個算法，比之前的哈希算法具有更強的安全強度和更靈活的輸出長度，分別為 SHA - 512 / 224、SHA - 512 / 256。
		* ### SHA - 256 為常用算法，輸入最大長度小於 264 bit，輸出是 256 的消息摘要，輸入消息以 512 bit 分組為單位進行處理。
	* ### SHA - 3
		* ### 美國政府選用 Keccak 算法作為 SHA - 3 算法的加密標準，因為其擁有良好的加密性能以及抗解密能力。
	* ### RIPEMD
		* ### RACE Integrity Primitives Evaluation Message Digest，即 RACE 原始完整性校驗消息的摘要。
		* ### 使用 MD4 設計原理，並針對其缺陷進行改進。
		* ### 性能與 SHA - 1 算法相似。
* ### SHA - 1 已被破解。
* ### SHA - 2 為使用範圍較為廣泛的算法，經常用於數位簽章領域。
* ### 區塊鏈中主流雜湊算法為 SHA - 256。
* ### SHA - 256 Java 實戰
	* ### 基於 Apache commons - codec 的工具類實現 SHA - 256 加密，也可使用 Hutool 的工具類實現。
3.3 Merkle 樹
-----
* ### 維基百科
	* ### 雜湊樹（hash tree；Merkle tree），在密碼學及電腦科學中是一種樹形資料結構，每個葉節點均以資料塊的雜湊作為標籤，而除了葉節點以外的節點則以其子節點標籤的加密雜湊作為標籤。雜湊樹能夠高效、安全地驗證大型資料結構的內容，是雜湊鏈的推廣形式。
	* ### ![image](https://www.itread01.com/uploads/images/20170216/1487247604-1165.jpg)
* ### Merkle 樹在數字貨幣、零知識證明、文件完整性校驗等領域有廣泛的應用。
* ### 比特幣和以太坊系統中利用 Merkle proofs 來儲存每個區塊的交易。
* ### Git 也是通過 Merkle 樹來進行完整性校驗。
* ### 在區塊鏈中，Merkle 樹最常見的使用方式就是構建交易數據對應的 Merkle 樹，並計算得到 Merkle 樹根節點的雜湊值。
* ### Merkle 樹 Java 實戰
	* ### 區塊鏈系統中，不僅會用到根節點的哈希值，還需要基於 Merkle 樹驗證交易的有效性。
3.4 小結
-----
* ### 區塊鏈中密碼學分支
	* ### 加密
	* ### 雜湊
	* ### Merkle Tree
