2 - 时间空间复杂度分析
=====
* ### "大 O 符号表示法" (BigO): T(n) = O(f(n))
    * ### T(n): 渐进时间复杂度。
    * ### f(n): 代码执行次数總和。
    * ### O: 正比例关系。
* ### 除了 "大 O 表示法" 还有其他 "平均时间复杂度"、"均摊时间复杂度"、"最坏时间复杂度"、"最好时间复杂度" 等等分析指数，但是最常用的依然是 "大 O 表示法"。
* ### Example 1
    ```
    for (int i = 1; i <= n; i++) {
        x++;
    }
    ```
    * ### for loop 有 n 个循环，假设 x++ 计算的消耗是一个单位，第一次循环是 1 单位，第二次循环是 2 单位，整个循环语句就要消耗 n 个单位。
    * ### 消耗的单位时间随着循环的次数而变化，循环次数为 1，时间为 1 单位；循环次数为 10，时间为 10 单位；循环次数为 n，时间为 n 单位。
    * ### 所以 "时间复杂度" 为: T(n) = O(n)。
    * ### 严格计算下，int i = 1 也要消耗 1 单位时间，i <= n 和 i++ 也都需要 1 单位时间，所以 "时间复杂度" 是 T(n) = 1 + 3n。
    * ### 此例中，如果 n 无限大的时候，T(n) = 1 + 3n 中的常数 1 就没有意义了，倍数 3 也影响不大，所以简化为 T(n) = O(n)。
* ### Example 2
    ```
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            x++;
        }
    }
    ```
    * ### 在外层循环中，i 总共需要 n 层循环，在每一次内层循环中，j 也会循环 n 次，两个循环语句的复杂度就是 O(n ^ 2)。
* ### Eaxmple 3
    ```
    for (int i = 1; i <= n; i++) {
        x++;
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            x++;
        }
    }
    ```
    * ### 复杂度为 O(n + n ^ 2)，在 n 无限大的情况下，可以简化为 O(n ^ 2)。
* ### 时间复杂度量级
    * ### ![image](https://raw.githubusercontent.com/GitHub-WeiChiang/main/master/DataStructuresAndAlgorithms/Basic/2/big-o-running-time-complexity.png)
    * ### 常数阶: O(1)
    * ### 对数阶: O(log n)
    * ### 线性阶: O(n)
    * ### 线性对数阶: O(n log n)
    * ### 平方阶: O(n ^ 2)
    * ### 立方阶: O(n ^ 3)
    * ### K 次方阶: O(n ^ k)
    * ### 指数阶: (2 ^ n)
    * ### 阶乘: O(n!)
* ### 常数阶 O(1)
    ```
    int x = 0;
    int y = 1;
    int temp = x;
    x = y;
    y = temp;
    ```
    * ### 消耗时间不会随着特定变量的增长而增长，可以用 O(1) 表示时间复杂度。
* ### 线性阶 O(n)
    ```
    for (int i = 1; i <= n; i++) {
        x++;
    }
    ```
    * ### 消耗的时间随着 n 的变化而变化，可以用 O(n) 表示时间复杂度。
* ### 对数阶 O(log n)
    ```
    int i = 1;
    while (i < n) {
        i = i * 2;
    }
    ```
    * ### i 会被乘以 2 數次，也意味着每次 i 都离 n 更进一步。
    * ### 多少次循环 i 才能等于或大于 n，也就是求解 2 的 x 次方等于 n。
    * ### ```x = log ^ n```: 循环 log ^ n 次之后，i 会大于等于 n。
    * ### 时间复杂度为: O(log n)。
* ### 线性对数阶 O(n log n)
    ```
    for(int i = 0; i <= n: i++) {
        int x = 1;
        while(x < n) {
            x = x * 2;
        }
    }
    ```
    * ### 每次循环的复杂度为 O(log n)，所以 n * log n = O(n log n)。
* ### 平方阶 O(n ^ 2)
    ```
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            x++;
        }
    }
    ```
    * ### 时间复杂度为 (将循环次数为 n 的代码再循环 n 遍): O(n²)。
    ```
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            x++;
        }
    }
    ```
    * ### 时间复杂度为: O(n * m)。
* ### 空间复杂度: 反映内存空间增长的趋势。
* ### 常用的空间复杂度
    * ### O(1)
    * ### O(n)
    * ### O(n ^ 2)
* ### O(1) 空间复杂度
    ```
    int x = 0;
    int y = 0;
    x++;
    y++;
    ```
    * ### x, y 所分配的空间不随着处理数据量变化，因此「空间复杂度」为 O(1)。
* ### O(n) 空间复杂度
    ```
    int[] newArray = new int[n];
    for (int i = 0; i < n; i++) {
        newArray[i] = i;
    }
    ```
    * ### 「空间复杂度」取决于 newArray 的长度，也就是 n，所以「空间复杂度」為 O(n)。
* ### O(n ^ 2): 二維陣列。
<br />
