Chapter02 Thread 的真相
=====
* ### 在開始之前，先搞清楚以下的名詞 (個人認為是拜 GIL 所賜，所以有了這三種選擇):
  * ### Thread: "執行緒"，又稱 "線程"，可以實現 "Concurrent"，由 ```threading``` 模組實作。
  * ### Process: "行程"，又稱 "進程"，可以實現 "Parallel"，由 ```multiprocessing``` 模組實作。
  * ### Coroutine: "協程"，又稱 "異步" 與 "微線程"，可以實現 "Concurrent"，由 ```asyncio``` 模組實作。
    * ### A "coroutine" is a "concurrency" design pattern.
    * ### "Coroutines" are like threads executing work "concurrently".
  * ### ![image](https://raw.githubusercontent.com/GitHub-WeiChiang/main/master/AsyncioPrinciples/Chapter02/ConcAndPara.jpg)
* ### 名詞對照
  * ### Thread
    * ### 台灣: 執行緒
    * ### 中國: 線程
  * ### Process
    * ### 台灣: 行程
    * ### 中國: 進程
  * ### Concurrent
    * ### 台灣: 並行
    * ### 中國: 並發
  * ### Parallel
    * ### 台灣: 平行
    * ### 中國: 並行
* ### 執行緒是作業系統提供的特性，軟體開發者用來告訴作業系統 (OS)，程式中哪部分可以同時處理，「OS 會決定如何共享 CPU 資源，就像 OS 決定了不同程式 (行程) 間，如何共享 CPU 資源以便同時執行」。
* ### 執行緒的優點
  * ### 程式碼易於閱讀: 程式碼被撰寫在單純由上而下的線性序列指令區，在函式中，不會發生並行 (執行緒安全)。
  * ### 共享記憶體: 衡量資源負擔的重要因素之一，如果要在不同行程的各自記憶體空間進行大量資料交換，會是一個很大的負擔。
  * ### 既有的經驗與程式碼: 有大量的 "阻斷式" 程式碼相關資料與最佳實踐可供參考。
* ### 運行執行緒的最佳實踐: 採用 concurrent.futures 模組的 ThreadPoolExecutor，透過 submit() 方法傳遞必要資料。
  ```
  from concurrent.futures import ThreadPoolExecutor as Executor

  def worker(data):
      print('<process the data>')

  with Executor(max_workers=10) as exe:
      future = exe.submit(worker, 'data')
  ```
  * ### 必要時可以將 ThreadPoolExecutor 改為 ProcessPoolExecutor，將執行緒池轉換為子行程池。
  * ### 關閉程式前需要呼叫 Executor.shutdown(wait=True)，等待 Executor 結束作業。
  * ### 應盡可能避免在執行緒程式碼 (例如上述範例的 worker 函數) 中存取全域變數。
* ### 執行緒的缺點
  * ### 執行緒難以處理: 執行緒中的臭蟲、競速等，是最難修正的問題種類，尤其是在複雜且設計草率的軟體中，即便是自認為專家的你 / 妳，也難以修正。
  * ### 執行緒是資源密集: 作業系統需要資源建立執行緒，像是為執行緒預配置堆疊空間 (事先就會消耗虛擬記憶體)，相較於 64 位元作業系統，對於 32 位元的作業系統來說，這是個嚴重的問題，至於在現代桌上型作業系統上，OS 甚至會在必要時，才為每個執行緒的堆疊空間配置需要的實體記憶體。
    ```
    # 假設在具有 8 GB 記憶體、現代的 64 位元 Fedora 29 Linux 上，
    # 建立 10000 個像我一樣愛睡覺的執行緒。
    
    import os
    
    from time import sleep
    from threading import Thread
    
    threads = [
        Thread(target=lambda: sleep(60)) for i in range(10000)
    ]
    
    [t.start() for t in threads]
    
    print(f'PID = {os.getpid()}')
    
    [t.join() for t in threads]
    
    # 預先配置的虛擬記憶體將達到 80 GB，
    # 雖然可以透過 threading.stack_size([size]) 修改預設堆疊大小，
    # 但這意味著減少了執行時期函式可巢狀呼叫 (包含遞迴) 的安全性，
    # 而 "具有單執行緒特性" 的 "協程" 就沒有這些問題，
    # 對於並行 I/O 來說是一個很好的解決方案。
    ```
  * ### 執行緒會影響產能: 極大規模的並行 (像是超過 5000 個執行緒) 會因為環境切換的成本而影響產能 (throughput)，而且這還有一個前提是你 / 妳知道如何設定作業系統允許建立如此大量的執行緒，尤其在 macOS 上極為麻煩 (上述的程式範例在我的 macbook 上是無法執行的)。
  * ### 執行緒缺乏彈性 (這是一個嚴重的問題): 無論執行緒是否準備好執行作業，OS 都會不對地分配 CPU 時間給所有的執行緒，即便該執行序可能在等待 socket 的資料，它還是有機率獲得執行權，OS 排班器仍會來回不斷的切換該執行緒 (在非同步的世界中，select() 系統呼叫會檢查是否輪到 socket 等待的協程，若否則不會甦醒該協程，完全避免非適當切換的成本與無意義等待的效能損耗)。
    * ### Windows: 主要並行機制透過執行緒實作，其建立與使用很簡單，但管理卻需要消耗大量的時間與資源，優先序相同的執行序雖然獲得相應對等的執行時間，但開發者也必須給予適當大小的作業，對於較小或粒度更細的作業，並行的成本可能遠超過其所帶來的好處。
    * ### Unix: 執行緒會有記憶體與效能上的成本，執行緒所對應的記憶體配置包含核心 (Kernel) 記憶體空間與程式記憶體空間，管理執行緒與協調排班時所需架構被儲存在固定記憶體 (Wired Memory) 的核心中，另外還有執行緒的堆疊空間與其餘資料所佔用的記憶體空間，這些在執行緒生成時建立並初始化以便與核心進行溝通的作業過程，成本是非常昂貴的。
  * ### 其它: 多執行緒程式設計本身具有一定的複雜度，要寫出出色的多執行緒程式也相對困難，更何況在多執行緒程式中大概率會使用同步機制，這不但增加了軟體設計的複雜度與風險，還不能保證效能上的增益。
  * ### 結論: 執行緒使程式碼難以理解、執行緒對於大規模並行的場景 (數以萬計的並行作業) 是個沒有效率的模型。
* ### 案例研究: 機器人與餐具 (cutlery_test.py)
  * ### 場景: 執行 "準備餐桌" 與 "清潔餐桌" 演示 (四組刀叉的擺放與回收)。
  * ### 問題: 結束時的刀叉總數量可能與初始化時不同。
  * ### 特色
    * ### 程式碼易於閱讀。
    * ### 少量作業不會造成刀叉總數量不同問題。
    * ### 大規模作業可能造成刀叉總數量不同問題。
    * ### 錯誤無法重現。
  * ### 原因
    ```
    def change(self, knives, forks):
        # with self.lock:
        self.knives += knives
        self.forks += forks
    ```
  * ### 指定運算 ```+=``` 的內部實作步驟:
    * ### 讀取被操作的值至暫存區。
    * ### 對在暫存區的值進行操作。
    * ### 將在暫存區的值複製回去。
* ### 先佔式多執行緒問題: 執行緒在任何時候都可能被中斷，也就是沒有執行緒可能切換處的任何線索。
* ### 如果能夠掌握多執行緒共享狀態的位置 (全部原始碼是受控的)，沒什麼問題，但若套用大量第三方程式庫亦或是既有程式當初的撰寫者是一個白痴導致現在的維護者難以掌握，事情就有點悲劇了。
* ### 在 "非同步程式" 中，就 "能明確地看出" 多個並行協程間 "切換的位置"，因為 ```await``` 關鍵字能明確地指出這些地方。
* ### 虛擬記憶體: 虛擬記憶體 (亦稱為分頁檔) 是存在於硬碟或固態硬碟的區塊空間，在實體記憶體不夠大量執行程式時，由作業系統定址後作為 RAM 使用。其提供額外的 "假性" RAM 以便讓程式持續運作，但由於 HDD 與 SSD 的存取速度與效能遠不如真正的 RAM，故在使用虛擬記憶體時，將明顯感受到效能降低。
<br />
