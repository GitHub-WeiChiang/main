七大編程原則
=====
* ### SingleResponsibility 單一職責: 一個類別應該只專注於一項事物。
* ### OpenClose 開閉: 類別架構應該對架構應該對擴展開放而對修改封閉。
* ### LawOfDemeter 迪米特法則: 類別應只和自己關係密切的類別溝通。
* ### DependencyInversion 依賴倒置: 高階類別與低階類別間應該要有一個抽象的中介接口。
* ### CompositeReuse 合成復用: 應該多使用關聯、聚合與組合，少使用繼承。
* ### InterfaceSegregation 接口隔離: 客戶 (類別) 不應該依賴 (實作) 它不需要的接口，且接口的設計應要符合單一職責原則。
* ### LiskovSubstitution 里氏替換: 任何父類別可以出現的地方，其子類別一定也可以出現。
<br />

The SOLID Principles of Object Oriented
=====
* ### The ```S```ingle Responsibility Principle
* ### The ```O```pen Closed Principle
* ### The ```L```iskov Substitution Principle
* ### The ```I```nterface Segregation Principle
* ### The ```D```ependency Inversion Principle
<br />

編成原則整理
=====
* ### 面對對象設計 (高層設計)
    * ### 開閉 (目標): 對擴展開放，對修改關閉。
    * ### 依賴倒置 (手段): 依賴於抽象而非具體。
* ### 拆分解構
    * ### 單一職責 (業務上): 類的職責要明確且功能要單一。
    * ### 接口隔離 (架構上): 類應該只依賴真正有關聯的接口。
* ### 類之間的通信
    * ### 合成復用: 關聯、聚合與組合都優於繼承。
    * ### 里氏替換: 子類別應該可以取代服類別，反之則否。
    * ### 迪米特法則: 類應該只和真正有關聯的類溝通。
<br />

設計模式分類
=====
| 行為型 | 結構性 | 創建型 |
| --- | --- | --- |
| Chain of Responsibility | Adapter | Abstract Factory |
| Command | Bridge | Builder |
| Interpreter | Composite | Factory Method |
| Iterator | Decorator | Prototype |
| Mediator | Facade | Singleton |
| Memento | Flyweight |  |
| Observer | Proxy |  |
| State |  |  |
| Strategy |  |  |
| Template Method |  |  |
| Visitor |  |  |
<br />

創建型模式
=====
* ### 幫助創建類或是對象。
* ### 將創建與使用分離，使兩者相互獨立。
<br />

結構性模式
=====
* ### 涉及對象的組合，獲得更好與靈活的結構。
* ### 更多的透過組合與運行期的動態結合實現。
<br />

行為型模式
=====
* ### 描述類或是對象如何交互分配職責。
* ### 涉及算法與對象間職責分配，描述一組對象應如何協作完成一個整體功能。
<br />

設計模式
=====
* ### 抽象工廠 Abstract Factory: 創建一系列相互依賴的類。
    * ### 遊戲皮膚
* ### 生成器 Builder: 創建各實例生成所需不同的類。
* ### 工廠方法 Factory Method: 創建需要使用大量重複代碼對象。
* ### 原型 Prototype: 支持相同物件的大量複製。
* ### 單例 Singleton: 保證一個類只有一個實例。
    * ### 資源分享: 數據庫、緩存
    * ### 配置管理
    * ### 日誌管理
* ### 適配器 Adapter: 讓接口不兼容的對象能夠相互合作 (後期維護兼容)。
    * ### 第三方庫鏈接
    * ### 單元測試: 真實對象行為模擬
* ### 橋接 Bridge: 將抽象與實現分離，在抽象和現實間搭建橋樑 (前期架構設計)。
    * ### GUI 框架
    * ### 繪圖程序
    * ### 數據庫驅動系統
* ### 組合 Composite: 實現遞歸樹狀結構。
    * ### 檔案系統
* ### 裝飾器 Decorator: 在運行時動態添加新功能。
    * ### GUI 可視化組件
    * ### 通信協議
    * ### 日誌系統
    * ### 權限控制系統
* ### 外觀 Facade: 為複雜系統提供簡單接口。
    * ### 複雜 Lib 簡化
    * ### 跨平台程序
    * ### 電商系統
* ### 享元 Flyweight: 節省內存使用。
    * ### 文字編輯與處理器
    * ### 圖形應用
    * ### 遊戲開發
* ### 代理 Proxy: 讓一個類代表另一個類。
    * ### 訪問控制
    * ### 緩存
    * ### 保護代理
    * ### 遠程對象
    * ### 智能引用
    * ### 日誌記錄
    * ### 監控審計
* ### 責任鏈 Chain Of Responsibility: 支援多對象按序請求處理。
    * ### 中間件
    * ### GUI 事件處理
    * ### 異常處理
    * ### 工作流
* ### 命令 Command: 把請求轉換成單獨的類。
    * ### 文本編輯器
    * ### 圖形編輯器
* ### 解釋器 Interpreter: 評估語言語法或表達式。
    * ### 編譯器與解譯器。
    * ### 配置文件解析器。
    * ### 查詢語言解析器。
* ### 迭代器 Iterator: 遍歷集合元素的模式。
    * ### 數據庫訪問。
    * ### 文件系統。
    * ### 社交網絡。
* ### 中介者 Mediator: 用中介封裝一系列的對象交互。
    * ### 聊天應用。
    * ### 空中交通控制系統。
    * ### GUI 框架。
    * ### MVC 架構。
    * ### 工作流引擎。
* ### 備忘錄 Memento: 保存並恢復對象的內部狀態。
    * ### 文本編輯器。
    * ### 繪圖應用程序。
    * ### 數據庫系統。
    * ### 遊戲開發。
    * ### 版本控制系統。
* ### 觀察者 Observer: 定義對象間的一對多依賴關係。
    * ### 社交媒體平台。
    * ### 股票市場。
    * ### GUI 工具。
    * ### 實時消息系統。
* ### 狀態 State: 允許一個對象在其內部狀態改變時改變其行為。
    * ### 遊戲角色狀態切換。
    * ### 網絡連接狀態管理。
    * ### 訂單狀態管理。
* ### 策略 Strategy: 定義並封裝一系列算法。
    * ### 支付方式。
    * ### 壓縮和解壓縮算法。
    * ### 圖像渲染。
* ### 樣板方法 Template: 定義算法的骨架。
    * ### 數據庫訪問。
    * ### GUI 設計。
    * ### 框架和庫。
* ### 訪問者 Visitor: 將算法和數據結構分離。
    * ### 編譯器。
    * ### 文檔轉換。
<br />

Reference
=====
* ### 图灵星球 Turing Planet: 设计模式快速入门教程
<br />
